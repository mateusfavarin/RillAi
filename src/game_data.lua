-- Connecting to the python script
local host, port = "127.0.0.1", 8001
local socket = require("socket")
local tcp = assert(socket.tcp())
tcp:connect(host, port)
tcp:send("Connected")

msg = ""
cooldown_msg = ""

mash_cross = true
reward = {0, 0, 0, 0}
can_kick = {true, true, true, true}
frame_count = 1
first_msg = true
in_game = false
controller = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}
buttons = {
    {0, 0, 0, 0},
    {1, 0, 1, 0},
    {0, 1, 1, 0},
    {0, 0, 0, 1},
}

END_OF_FRAME = 0xBA11
END_OF_GAME = 0xDEAD
AVG_GAMES = 100

NUM_FRAMES = 3

REWARD_KICK = 1
REWARD_TOUCH = 1
PUNISHMENT_LOST_POINT = -1

decay = 0.0000009
epsilon = 1
min_epsilon = 0.01

-- AI stats
stat_balls_scored = {0, 0, 0, 0}
stat_balls_kicked = {0, 0, 0, 0}
stat_balls_hit = {0, 0, 0, 0}
kicks_missed = {0, 0, 0, 0}
reward_game = {0, 0, 0, 0}
games_played = 0
wins = {0, 0, 0, 0}
total_balls_scored = {0, 0, 0, 0}
total_balls_goal = 0

pointer = 1

reward_last_games = {{}, {}, {}, {}}
for i = 1, 4 do
    for j = 1, AVG_GAMES do
        reward_last_games[i][j] = 0
    end
end

average_reward = {0, 0, 0, 0}

win_last_games = {{}, {}, {}, {}}
for i = 1, 4 do
    for j = 1, AVG_GAMES do
        win_last_games[i][j] = 0
    end
end

average_win = {0, 0, 0, 0}

local function split(inputstr)
    sep = "%s"
    local t={}
    for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
        table.insert(t, str)
    end
    return t
end

local function round(n)
    return math.floor(n * 100) / 100
end

local function read_pointer(address)
    x = memory.read_u32_le(address)
    if (x == 0) then
        return 0
    end
    return memory.read_u32_le(address) - 0x80000000
end

local function game_is_alive()
    -- Checking the 3...2...1... clock
    countdown = memory.read_u32_le(0x09BD40)
    -- If the countdown is over
    if countdown == 4 then
        -- if less than 3 players have 0 points
        dead_count = 0
        for player_id = 0, 3 do
            player_score = memory.read_u8(0x09D57C + player_id * 0x6C)
            if player_score == 0 then
                dead_count = dead_count + 1
            end
        end
        if dead_count < 3 then
            in_game = true
            return true
        end
    end
    -- Game is over
    return false
end

local function get_player_data()
    -- Static addresses
    player_pointer = 0x09D530
    cooldown_addr = 0x09D592
    colision_array = 0x074900
    kick_array = 0x074910
    goal = 0x074920

    for player_id = 0, 3 do

        -- Getting the player position
        player_struct = read_pointer(player_pointer + player_id * 0x6C)

        player_score = memory.read_u8(0x09D57C + player_id * 0x6C)

        if player_score > 0 then
            if player_id < 2 then
                pos = memory.read_s32_le(player_struct + 0x10)
            else
                pos = memory.read_s32_le(player_struct + 0x18)
            end
        else
            pos = END_OF_GAME
        end

        msg = msg .. pos .. " "

        -- Getting the player cooldown for square
        kick_cooldown = memory.read_u16_le(cooldown_addr + player_id * 0x6C)

        -- If you're in the frame to send the message, attach your kick cooldown
        if frame_count == NUM_FRAMES then
            if kick_cooldown > 0 then
                cooldown_msg = cooldown_msg .. "0 "
            else
                cooldown_msg = cooldown_msg .. "1 "
            end
        end

        -- Getting the number of balls hit and kicked
        balls_hit = memory.read_u32_le(colision_array + 4 * player_id)
        balls_kicked = memory.read_u32_le(kick_array + 4 * player_id)

        -- Calculating the reward generated by the actions
        reward[player_id + 1] = reward[player_id + 1] + balls_hit * REWARD_TOUCH + balls_kicked * REWARD_KICK

        stat_balls_hit[player_id + 1] = stat_balls_hit[player_id + 1] + balls_hit
        stat_balls_kicked[player_id + 1] = stat_balls_kicked[player_id + 1] + balls_kicked

        -- resetting the counter at the end of the frame
        memory.write_u32_le(colision_array + 4 * player_id, 0)
        memory.write_u32_le(kick_array + 4 * player_id, 0)

        -- Checking whether the kick missed or hit
        kick_state = memory.read_u16_le(0x09D558 + 4 * player_id)
        if kick_state == 0x1F then
            -- If you kicked, then you can't kick again
            can_kick[player_id + 1] = false
        else
            if not can_kick[player_id + 1] then
                -- If the kick missed, your cooldown is greater than zero, gather the data
                if kick_cooldown > 0 then
                    kicks_missed[player_id + 1] = kicks_missed[player_id + 1] + 1
                end
                -- You can kick again
                can_kick[player_id + 1] = true
            end
        end
    end

    -- Checking if anyone scored any ball
    player_who_scored = memory.read_s16_le(goal)
    if player_who_scored ~= -1 then
        stat_balls_scored[player_who_scored + 1] = stat_balls_scored[player_who_scored + 1] + 1
    end

    -- Resetting the data of the player who scored
    memory.write_s16_le(goal, -1)
end

local function get_ball_data()
    -- Loop the ball linked list
    ball_linked_list_start = 0x05AA38
    curr_ball_ptr = read_pointer(ball_linked_list_start)
    -- the game can spawn more than 5 balls in the very last frame of a finished game, so
    -- to avoid the software breaking, lets only gather the maximum of 5 balls
    ball_count = 0

    while curr_ball_ptr ~= 0 do

        -- Read ball structutes
        ball_properties = read_pointer(curr_ball_ptr + 0x58)
        ball_state = memory.read_u16_le(ball_properties + 0x1A)

        -- if a ball can be hit by the player, send its data
        if ball_state == 0x1 then
            ball_struct = read_pointer(curr_ball_ptr + 0x54)
            x_pos = memory.read_s32_le(ball_struct + 0x10)
            y_pos = memory.read_s32_le(ball_struct + 0x18)
            msg = msg .. x_pos .. " " .. y_pos .. " "
        else
            -- if a ball was scored, punish the player that let the ball in
            if ball_state == 0x12 then
                goal_id = memory.read_u16_le(ball_properties + 0x16)
                reward[goal_id + 1] = reward[goal_id + 1] + PUNISHMENT_LOST_POINT
            end
        end

        -- gathering at most data from 5 balls
        ball_count = ball_count + 1
        if ball_count == 5 then
            break
        end

        -- Go to the next ball of the linked list
        curr_ball_ptr = read_pointer(curr_ball_ptr + 0x20)
    end
end

local function reset_game_variables(end_game)
    msg = ""
    cooldown_msg = ""
    reward = {0, 0, 0, 0}
    frame_count = 0
    if end_game then
        can_kick = {true, true, true, true}
        first_msg = true
        controller = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}
        frame_count = 1
        stat_balls_scored = {0, 0, 0, 0}
        stat_balls_kicked = {0, 0, 0, 0}
        stat_balls_hit = {0, 0, 0, 0}
        kicks_missed = {0, 0, 0, 0}
        reward_game = {0, 0, 0, 0}
        -- Resetting players win counter
        for i = 0, 3 do
            memory.write_u8(0x05A6E0 + i, 0)
        end
    end
end

local function send_message()
    if first_msg then
        first_msg = false
    else
        reward_msg = ""
        for i = 1, 4 do
            reward_game[i] = reward_game[i] + reward[i]
            reward_msg = reward_msg .. reward[i] .. " "
        end
        tcp:send(reward_msg)
        feedback, status, partial = tcp:receive()
    end

    tcp:send(msg)
    action, status, partial = tcp:receive()
    action = split(action)

    for i = 1, 4 do
        controller[i] = buttons[tonumber(action[i]) + 1]
    end

    epsilon = epsilon - decay
    if (epsilon < min_epsilon) then
        epsilon = min_epsilon
    end

    reset_game_variables(false)
end

local function send_inputs()
    joypad.set({Left=controller[1][1], Right=controller[1][2], R1=controller[1][3], Square=controller[1][4]}, 1)
    joypad.set({Right=controller[2][1], Left=controller[2][2], R1=controller[2][3], Square=controller[2][4]}, 2)
    joypad.set({Down=controller[3][1], Up=controller[3][2], R1=controller[3][3], Square=controller[3][4]}, 3)
    joypad.set({Up=controller[4][1], Down=controller[4][2], R1=controller[4][3], Square=controller[4][4]}, 4)
end

local function update_stats()
    games_played = games_played + 1

    reward_txt = ""
    for i = 0, 3 do
        player_score = memory.read_u8(0x09D57C + i * 0x6C)
        total_balls_goal = total_balls_goal + 15 - player_score

        if player_score > 0 then
            wins[i + 1] = wins[i + 1] + 1
            win_last_games[i + 1][pointer] = 1
        else
            win_last_games[i + 1][pointer] = 0
        end
        reward_last_games[i + 1][pointer] = reward_game[i + 1]

        reward_txt = reward_txt .. reward_game[i + 1] .. " "

        n = 0
        k = 0
        for j = 1, AVG_GAMES do
            n = n + reward_last_games[i + 1][j]
            k = k + win_last_games[i + 1][j]
        end
        n = n / math.min(AVG_GAMES, games_played)
        k = k / math.min(AVG_GAMES, games_played)

        average_reward[i + 1] = n
        average_win[i + 1] = k

        total_balls_scored[i + 1] = total_balls_scored[i + 1] + stat_balls_scored[i + 1]
    end

    file = io.open("reward_data.txt", "a")
    io.output(file)
    io.write(reward_txt .. "\n")
    io.close(file)

    pointer = pointer + 1

    if pointer > AVG_GAMES then
        pointer = 1
    end

end

local function draw_ui()
    names = {"Rilla Roo", "N. Brio", "Coco", "Koala Kong"}
    x = {50, 1050, 50, 1050}
    y = {50, 50, 350, 350}

    gui.text(500, 20, "Games played: " .. games_played, "white")
    gui.text(700, 20, "Rand: " .. string.format("%.2f", epsilon * 100) .. "%", "white")

    for i = 1, 4 do
        gui.text(x[i], y[i] - 20, names[i], "yellow")
        gui.text(x[i], y[i], "Wins: " .. wins[i], "white")
        gui.text(x[i], y[i] + 20, "Winrate: " .. string.format("%.2f", average_win[i] * 100) .. "%", "white")
        gui.text(x[i], y[i] + 40, "Avg reward: " .. string.format("%.2f", average_reward[i]), "white")
        gui.text(x[i], y[i] + 60, "Total balls scored: " .. total_balls_scored[i], "white")
        gui.text(x[i], y[i] + 80, "Score ratio: " .. string.format("%.2f", total_balls_scored[i] * 100 / total_balls_goal) .. "%" , "white")
        gui.text(x[i], y[i] + 100, "---------------------------", "white")
        gui.text(x[i], y[i] + 120, "Balls scored: " .. stat_balls_scored[i], "white")
        gui.text(x[i], y[i] + 140, "Kicks hit: " .. stat_balls_kicked[i], "white")
        gui.text(x[i], y[i] + 160, "Kicks missed: " .. kicks_missed[i], "white")
        gui.text(x[i], y[i] + 180, "Balls touched: " .. stat_balls_hit[i], "white")
        gui.text(x[i], y[i] + 200, "Reward: " .. string.format("%.2f", reward_game[i]), "white")
    end
end

-- Initializing the hack

-- Adding a collision counter to 0x80074900 (4 ints array)
memory.write_u32_le(0x0BE734, 0x31EF0000) -- andi t7, 0x0          | clearing t7
memory.write_u32_le(0x0BE73C, 0x3C0F8007) -- lui t7, 0x8007        | t7 = 0x80070000
memory.write_u32_le(0x0BE744, 0x35EF4900) -- ori t7, t7, 0x4900    | t7 = 0x80074900
memory.write_u32_le(0x0BE760, 0x0016C880) -- sll t9, s6, 0x2       | t9 = 4 * player_id
memory.write_u32_le(0x0BE788, 0x01F97820) -- add t7, t7, t9        | t7 = 0x80074900 + 4 * player_id
memory.write_u32_le(0x0BE794, 0x8DF90000) -- lw t9, 0x0(t7)        | t9 = current collision counter of the player
memory.write_u32_le(0x0BE99C, 0x27390001) -- addi t9, t9, 0x1      | t9 = increment counter by one
memory.write_u32_le(0x0BEA64, 0xADF90000) -- sw t9, 0x0(t7)        | t7 <- incremented counter

-- Adding a kick counter to 0x80074910 (4 ints array)
memory.write_u32_le(0x0BF078, 0x31EF0000) -- andi t7, 0x0          | clearing t7
memory.write_u32_le(0x0BF084, 0x3C0F8007) -- lui t7, 0x8007        | t7 = 0x80070000
memory.write_u32_le(0x0BF0A0, 0x35EF4910) -- ori t7, t7, 0x4910    | t7 = 0x80074900
memory.write_u32_le(0x0BF0B8, 0x97B90040) -- lhu t9, 0x40(sp)      | t9 = player_id
memory.write_u32_le(0x0BF0D0, 0x0019C880) -- sll t9, t9, 0x2       | t9 = player_id * 4
memory.write_u32_le(0x0BF104, 0x01F97820) -- add t7, t7, t9        | t7 = 0x80074900 + 4 * player_id
memory.write_u32_le(0x0BF124, 0x8DF90000) -- lw t9, 0x0(t7)        | t9 = current collision counter of the player
memory.write_u32_le(0x0BF12C, 0x27390001) -- addi t9, t9, 0x1      | t9 = increment counter by one
memory.write_u32_le(0x0BF194, 0xADF90000) -- sw t9, 0x0(t7)        | t7 <- incremented counter

-- Tracking who scored the ball
memory.write_u32_le(0x0BA734, 0x3C198007) -- lui t9, 0x8007        | t9 = 0x80070000
memory.write_u32_le(0x0BA754, 0x96AF0016) -- lhu t7, 0x16(s5)      | t7 = player_who_scored
memory.write_u32_le(0x0BA7EC, 0x37394920) -- ori t9, t9, 0x4920    | t9 = 0x80074920
memory.write_u32_le(0x0BA80C, 0xAF2F0000) -- sw t7, 0x0(t9)        | t9 <- player who scored the ball
memory.write_s16_le(0x074920, -1) -- Initializing the counter as -1

-- Main loop
while true do
    while game_is_alive() do
        get_player_data()
        get_ball_data()
        msg = msg .. cooldown_msg .. END_OF_FRAME .. " "
        if frame_count == NUM_FRAMES then
            send_message()
        end
        send_inputs()
        draw_ui()
        emu.frameadvance()
        send_inputs()
        draw_ui()
        emu.frameadvance()
        frame_count = frame_count + 1
    end

    if in_game then
        update_stats()
        reset_game_variables(true)
        -- if the game ends, tell the host
        tcp:send(END_OF_GAME)
        feedback, status, partial = tcp:receive()
        in_game = false
    end

    -- mash X button and draw the UI
    draw_ui()
    joypad.set({Cross=mash_cross}, 1)
    emu.frameadvance()
    draw_ui()
    joypad.set({Cross=mash_cross}, 1)
    emu.frameadvance()
    mash_cross = not mash_cross
end